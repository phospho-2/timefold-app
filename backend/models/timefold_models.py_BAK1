from dataclasses import dataclass, field
from datetime import time
from typing import List, Optional, Annotated

# ğŸ¯ æ­£ã—ã„Timefold APIå®Ÿè£… - å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæº–æ‹ 
from timefold.solver.domain import (
    planning_solution, planning_entity, PlanningVariable, PlanningId, ValueRangeProvider,
    ProblemFactCollectionProperty, PlanningEntityCollectionProperty, PlanningScore
)
from timefold.solver.score import HardSoftScore, constraint_provider, Joiners, ConstraintFactory, Constraint

# ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹å®šç¾© - Problem Facts
@dataclass
class Timeslot:
    id: int
    day_of_week: str
    start_time: time
    end_time: time
    
    def __str__(self):
        return f"{self.day_of_week} {self.start_time.strftime('%H:%M')}-{self.end_time.strftime('%H:%M')}"

@dataclass
class Room:
    id: int
    name: str
    
    def __str__(self):
        return self.name

@dataclass
class Subject:
    id: int
    name: str
    
    def __str__(self):
        return self.name

@dataclass
class Teacher:
    id: int
    name: str
    
    def __str__(self):
        return self.name

@dataclass
class StudentGroup:
    id: int
    name: str
    
    def __str__(self):
        return self.name

# ğŸ¯ Planning Entity - å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæº–æ‹ ã®æ­£ã—ã„æ§‹æ–‡
@planning_entity
@dataclass
class Lesson:
    id: Annotated[int, PlanningId]
    subject: Subject
    teacher: Teacher
    student_group: StudentGroup
    
    # ğŸš€ æ­£ã—ã„PlanningVariableæ§‹æ–‡ï¼ˆå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚ˆã‚Šï¼‰
    timeslot: Annotated[Timeslot | None, PlanningVariable] = field(default=None)
    room: Annotated[Room | None, PlanningVariable] = field(default=None)
    
    def __str__(self):
        return f"{self.subject} - {self.teacher} - {self.student_group}"

# ğŸ§  åˆ¶ç´„å®šç¾© - æœ¬æ ¼çš„ãªTimefoldåˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ 
@constraint_provider
def define_constraints(constraint_factory: ConstraintFactory):
    return [
        # Hard constraints (çµ¶å¯¾æ¡ä»¶)
        room_conflict(constraint_factory),
        teacher_conflict(constraint_factory),
        student_group_conflict(constraint_factory),
        
        # Soft constraints (æœ€é©åŒ–æ¡ä»¶)
        teacher_room_stability(constraint_factory),
        teacher_time_efficiency(constraint_factory),
    ]

def room_conflict(constraint_factory: ConstraintFactory) -> Constraint:
    """Hard: åŒã˜æ™‚é–“å¸¯ã«åŒã˜æ•™å®¤ã§è¤‡æ•°ã®æˆæ¥­ã¯ä¸å¯"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.timeslot),
                Joiners.equal(lambda lesson: lesson.room))
            .filter(lambda lesson1, lesson2: 
                lesson1.timeslot is not None and lesson2.timeslot is not None and 
                lesson1.room is not None and lesson2.room is not None)
            .penalize(HardSoftScore.ONE_HARD)
            .as_constraint("Room conflict"))

def teacher_conflict(constraint_factory: ConstraintFactory) -> Constraint:
    """Hard: åŒã˜æ™‚é–“å¸¯ã«åŒã˜å…ˆç”ŸãŒè¤‡æ•°ã®æˆæ¥­ã¯ä¸å¯"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.timeslot),
                Joiners.equal(lambda lesson: lesson.teacher))
            .filter(lambda lesson1, lesson2: lesson1.timeslot is not None and lesson2.timeslot is not None)
            .penalize(HardSoftScore.ONE_HARD)
            .as_constraint("Teacher conflict"))

def student_group_conflict(constraint_factory: ConstraintFactory) -> Constraint:
    """Hard: åŒã˜æ™‚é–“å¸¯ã«åŒã˜ã‚¯ãƒ©ã‚¹ãŒè¤‡æ•°ã®æˆæ¥­ã¯ä¸å¯"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.timeslot),
                Joiners.equal(lambda lesson: lesson.student_group))
            .filter(lambda lesson1, lesson2: lesson1.timeslot is not None and lesson2.timeslot is not None)
            .penalize(HardSoftScore.ONE_HARD)
            .as_constraint("Student group conflict"))

def teacher_room_stability(constraint_factory: ConstraintFactory) -> Constraint:
    """Soft: åŒã˜å…ˆç”Ÿã¯ã§ãã‚‹ã ã‘åŒã˜æ•™å®¤ã‚’ä½¿ã†ï¼ˆåŠ¹ç‡æ€§å‘ä¸Šï¼‰"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.teacher))
            .filter(lambda lesson1, lesson2: 
                lesson1.room is not None and lesson2.room is not None and 
                lesson1.room.id != lesson2.room.id)
            .penalize(HardSoftScore.ONE_SOFT)
            .as_constraint("Teacher room stability"))

def teacher_time_efficiency(constraint_factory: ConstraintFactory) -> Constraint:
    """Soft: åŒã˜å…ˆç”Ÿã®æˆæ¥­ã¯é€£ç¶šã™ã‚‹æ™‚é–“å¸¯ãŒç†æƒ³çš„ï¼ˆç§»å‹•åŠ¹ç‡ï¼‰"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.teacher))
            .filter(lambda lesson1, lesson2:
                lesson1.timeslot is not None and lesson2.timeslot is not None and
                lesson1.timeslot.day_of_week == lesson2.timeslot.day_of_week and
                abs(lesson1.timeslot.id - lesson2.timeslot.id) > 1)
            .penalize(HardSoftScore.ONE_SOFT)
            .as_constraint("Teacher time efficiency"))

# ğŸ¯ Planning Solution - å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæº–æ‹ ã®æ­£ã—ã„æ§‹æ–‡
@planning_solution
@dataclass  
class TimeTable:
    timeslots: Annotated[List[Timeslot], ProblemFactCollectionProperty, ValueRangeProvider] = field(default_factory=list)
    rooms: Annotated[List[Room], ProblemFactCollectionProperty, ValueRangeProvider] = field(default_factory=list)
    lessons: Annotated[List[Lesson], PlanningEntityCollectionProperty] = field(default_factory=list)
    score: Annotated[HardSoftScore | None, PlanningScore] = field(default=None)