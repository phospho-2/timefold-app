from dataclasses import dataclass, field
from datetime import time
from typing import List, Optional, Annotated

# ğŸ¯ æ­£ã—ã„Timefold APIå®Ÿè£… - å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæº–æ‹ 
from timefold.solver.domain import (
    planning_solution, planning_entity, PlanningVariable, PlanningId, ValueRangeProvider,
    ProblemFactCollectionProperty, PlanningEntityCollectionProperty, PlanningScore
)
from timefold.solver.score import (
    HardSoftScore, constraint_provider, Joiners, ConstraintFactory, Constraint
)

# ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹å®šç¾© - Problem Facts
@dataclass
class Timeslot:
    id: int
    day_of_week: str
    start_time: time
    end_time: time
    
    def __str__(self):
        return f"{self.day_of_week} {self.start_time.strftime('%H:%M')}-{self.end_time.strftime('%H:%M')}"

@dataclass
class Room:
    id: int
    name: str
    
    def __str__(self):
        return self.name

@dataclass
class Subject:
    id: int
    name: str
    
    def __str__(self):
        return self.name

@dataclass
class Teacher:
    id: int
    name: str
    
    def __str__(self):
        return self.name

@dataclass
class StudentGroup:
    id: int
    name: str
    
    def __str__(self):
        return self.name

# ğŸ¯ Planning Entity - å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæº–æ‹ ã®æ­£ã—ã„æ§‹æ–‡
@planning_entity
@dataclass
class Lesson:
    id: Annotated[int, PlanningId]
    subject: Subject
    teacher: Teacher
    student_group: StudentGroup
    
    # ğŸš€ æ­£ã—ã„PlanningVariableæ§‹æ–‡ï¼ˆå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚ˆã‚Šï¼‰
    timeslot: Annotated[Timeslot | None, PlanningVariable] = field(default=None)
    room: Annotated[Room | None, PlanningVariable] = field(default=None)
    
    def __str__(self):
        return f"{self.subject} - {self.teacher} - {self.student_group}"

# ğŸ§  åˆ¶ç´„å®šç¾© - æ”¹å–„ç‰ˆTimeFoldåˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ 
@constraint_provider
def define_constraints(constraint_factory: ConstraintFactory):
    return [
        # Hard constraints (çµ¶å¯¾æ¡ä»¶)
        room_conflict(constraint_factory),
        teacher_conflict(constraint_factory),
        student_group_conflict(constraint_factory),
        
        # Soft constraints (æœ€é©åŒ–æ¡ä»¶)
        teacher_room_stability(constraint_factory),
        teacher_time_efficiency(constraint_factory),
        subject_distribution_across_days(constraint_factory),  # æ–°è¦è¿½åŠ 
        balanced_daily_schedule(constraint_factory),           # æ–°è¦è¿½åŠ ï¼ˆç°¡ç´ ç‰ˆï¼‰
        avoid_consecutive_same_subject(constraint_factory),     # æ–°è¦è¿½åŠ 
    ]

def room_conflict(constraint_factory: ConstraintFactory) -> Constraint:
    """Hard: åŒã˜æ™‚é–“å¸¯ã«åŒã˜æ•™å®¤ã§è¤‡æ•°ã®æˆæ¥­ã¯ä¸å¯"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.timeslot),
                Joiners.equal(lambda lesson: lesson.room))
            .filter(lambda lesson1, lesson2: 
                lesson1.timeslot is not None and lesson2.timeslot is not None and 
                lesson1.room is not None and lesson2.room is not None)
            .penalize(HardSoftScore.ONE_HARD)
            .as_constraint("Room conflict"))

def teacher_conflict(constraint_factory: ConstraintFactory) -> Constraint:
    """Hard: åŒã˜æ™‚é–“å¸¯ã«åŒã˜å…ˆç”ŸãŒè¤‡æ•°ã®æˆæ¥­ã¯ä¸å¯"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.timeslot),
                Joiners.equal(lambda lesson: lesson.teacher))
            .filter(lambda lesson1, lesson2: lesson1.timeslot is not None and lesson2.timeslot is not None)
            .penalize(HardSoftScore.ONE_HARD)
            .as_constraint("Teacher conflict"))

def student_group_conflict(constraint_factory: ConstraintFactory) -> Constraint:
    """Hard: åŒã˜æ™‚é–“å¸¯ã«åŒã˜ã‚¯ãƒ©ã‚¹ãŒè¤‡æ•°ã®æˆæ¥­ã¯ä¸å¯"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.timeslot),
                Joiners.equal(lambda lesson: lesson.student_group))
            .filter(lambda lesson1, lesson2: lesson1.timeslot is not None and lesson2.timeslot is not None)
            .penalize(HardSoftScore.ONE_HARD)
            .as_constraint("Student group conflict"))

def teacher_room_stability(constraint_factory: ConstraintFactory) -> Constraint:
    """Soft: åŒã˜å…ˆç”Ÿã¯ã§ãã‚‹ã ã‘åŒã˜æ•™å®¤ã‚’ä½¿ã†ï¼ˆåŠ¹ç‡æ€§å‘ä¸Šï¼‰"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.teacher))
            .filter(lambda lesson1, lesson2: 
                lesson1.room is not None and lesson2.room is not None and 
                lesson1.room.id != lesson2.room.id)
            .penalize(HardSoftScore.ONE_SOFT)
            .as_constraint("Teacher room stability"))

def teacher_time_efficiency(constraint_factory: ConstraintFactory) -> Constraint:
    """Soft: åŒã˜å…ˆç”Ÿã®æˆæ¥­ã¯é€£ç¶šã™ã‚‹æ™‚é–“å¸¯ãŒç†æƒ³çš„ï¼ˆç§»å‹•åŠ¹ç‡ï¼‰"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.teacher))
            .filter(lambda lesson1, lesson2:
                lesson1.timeslot is not None and lesson2.timeslot is not None and
                lesson1.timeslot.day_of_week == lesson2.timeslot.day_of_week and
                abs(lesson1.timeslot.id - lesson2.timeslot.id) > 1)
            .penalize(HardSoftScore.ONE_SOFT)
            .as_constraint("Teacher time efficiency"))

def subject_distribution_across_days(constraint_factory: ConstraintFactory) -> Constraint:
    """Soft: åŒã˜ç§‘ç›®ã®æˆæ¥­ã¯ç•°ãªã‚‹æ›œæ—¥ã«åˆ†æ•£ã•ã›ã‚‹"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.subject),
                Joiners.equal(lambda lesson: lesson.student_group))
            .filter(lambda lesson1, lesson2:
                lesson1.timeslot is not None and lesson2.timeslot is not None and
                lesson1.timeslot.day_of_week == lesson2.timeslot.day_of_week)
            .penalize(HardSoftScore.of(0, 3))  # å¼·ã‚ã®ãƒšãƒŠãƒ«ãƒ†ã‚£
            .as_constraint("Subject distribution across days"))

def balanced_daily_schedule(constraint_factory: ConstraintFactory) -> Constraint:
    """Soft: 1æ—¥ã®æˆæ¥­æ•°ã‚’ãƒãƒ©ãƒ³ã‚¹è‰¯ãé…åˆ†ï¼ˆç°¡ç´ ç‰ˆï¼‰"""
    return (constraint_factory
            .for_each_unique_pair(Lesson)
            .filter(lambda lesson1, lesson2:
                lesson1.timeslot is not None and lesson2.timeslot is not None and
                lesson1.student_group.id == lesson2.student_group.id and
                lesson1.timeslot.day_of_week == lesson2.timeslot.day_of_week)
            .reward(HardSoftScore.of(0, 1))  # åŒã˜æ—¥ã«æˆæ¥­ãŒã‚ã‚‹ã“ã¨ã‚’è»½ãå ±é…¬
            .as_constraint("Balanced daily schedule"))

def avoid_consecutive_same_subject(constraint_factory: ConstraintFactory) -> Constraint:
    """Soft: åŒã˜ç§‘ç›®ã®é€£ç¶šæˆæ¥­ã‚’é¿ã‘ã‚‹ï¼ˆç–²åŠ´è»½æ¸›ï¼‰"""
    return (constraint_factory
            .for_each_unique_pair(Lesson,
                Joiners.equal(lambda lesson: lesson.subject),
                Joiners.equal(lambda lesson: lesson.student_group))
            .filter(lambda lesson1, lesson2:
                lesson1.timeslot is not None and lesson2.timeslot is not None and
                lesson1.timeslot.day_of_week == lesson2.timeslot.day_of_week and
                abs(lesson1.timeslot.id - lesson2.timeslot.id) == 1)  # é€£ç¶šã™ã‚‹æ™‚é–“å¸¯
            .penalize(HardSoftScore.of(0, 2))
            .as_constraint("Avoid consecutive same subject"))

# ğŸ¯ Planning Solution - å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæº–æ‹ ã®æ­£ã—ã„æ§‹æ–‡
@planning_solution
@dataclass  
class TimeTable:
    timeslots: Annotated[List[Timeslot], ProblemFactCollectionProperty, ValueRangeProvider] = field(default_factory=list)
    rooms: Annotated[List[Room], ProblemFactCollectionProperty, ValueRangeProvider] = field(default_factory=list)
    lessons: Annotated[List[Lesson], PlanningEntityCollectionProperty] = field(default_factory=list)
    score: Annotated[HardSoftScore | None, PlanningScore] = field(default=None)